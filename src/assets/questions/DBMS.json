{
  "subject": "DBMS - 50 Interview Questions",
  "total_questions": 50,
  "difficulty": "Fresher to Intermediate",
  "answer_length": "50-70 words",
  "companies": ["Infosys", "TCS", "Wipro", "Accenture", "HCL", "Cognizant", "Capgemini", "Deloitte", "Amazon", "Microsoft", "Google", "Adobe", "Flipkart", "Oracle", "IBM"],
  "questions": [
    {"id": 1, "question": "What is DBMS?", "answer": "DBMS (Database Management System): software managing database creation, manipulation, storage, retrieval. Functions: data storage, integrity enforcement, concurrent access, security, backup/recovery, query processing, transaction management. Advantages over file systems: reduced redundancy, consistency, efficient access, security, concurrent support, recovery capability. Examples: MySQL, Oracle, PostgreSQL, MongoDB. Essential for data-centric applications managing large complex datasets."},
    {"id": 2, "question": "What is Normalization?", "answer": "Normalization: process organizing data reducing redundancy, improving integrity. Normal forms: 1NF (atomic values), 2NF (full key dependency), 3NF (no transitive dependencies), BCNF (every determinant is candidate key). Benefits: eliminates anomalies, ensures consistency. Trade-off: higher forms reduce redundancy but increase query complexity. Essential for relational database design."},
    {"id": 3, "question": "What is 1NF?", "answer": "First Normal Form (1NF): all attributes contain atomic values (indivisible). No repeating groups, multi-valued attributes, or nested tables. Each cell single value. Example: StudentCourse(StudentID, CourseID) instead of Student(StudentID, Courses) where Courses multi-valued. Eliminates repeating group anomalies. Foundation for higher normal forms. Required before applying 2NF."},
    {"id": 4, "question": "What is 2NF?", "answer": "Second Normal Form (2NF): must be 1NF AND all non-key attributes fully depend on entire primary key. Removes partial dependencies. Example: Table(StudentID, CourseID, InstructorName) where InstructorName depends only on CourseID (partial). Solution: separate tables. Ensures composite key dependencies correct. Prevents update anomalies from partial key dependencies."},
    {"id": 5, "question": "What is 3NF?", "answer": "Third Normal Form (3NF): must be 2NF AND no transitive dependencies. Non-key attributes shouldn't depend on other non-key attributes. Example: StudentCourse(StudentID, CourseID, DepartmentID, DepartmentName) where DepartmentName depends on DepartmentID. Solution: separate Department table. Most practical form. Handles majority real-world scenarios. Balances efficiency and consistency."},
    {"id": 6, "question": "PRIMARY KEY vs FOREIGN KEY?", "answer": "PRIMARY KEY: uniquely identifies each record, not NULL, one per table, enforces entity integrity. FOREIGN KEY: references primary key of another table, can be NULL, multiple allowed, enforces referential integrity, establishes relationships. Together ensure database integrity. Example: StudentID PK in Student, StudentID FK in Enrollment. Enable relational model."},
    {"id": 7, "question": "What is ACID?", "answer": "ACID: properties ensuring reliable transactions. Atomicity (all-or-nothing), Consistency (valid state transition), Isolation (independent execution), Durability (persistent after commit). Together guarantee: no partial updates, consistent state maintained, concurrent transactions don't interfere, committed data survives failures. Essential for database reliability. Trade-off: overhead reduces performance. Balance required for system."},
    {"id": 8, "question": "What is Atomicity?", "answer": "Atomicity: transaction completely succeeds or completely fails (all-or-nothing). No partial updates. Implementation: uses UNDO logs. Before modifying, old values logged. If failure, values restored. Example: transfer $100 account A to B. Either A decreased and B increased, or neither. Never A decreased, B unchanged. Ensures consistency."},
    {"id": 9, "question": "What is Consistency?", "answer": "Consistency: database transitions from one valid state to another. All constraints, rules maintained. Database never inconsistent intermediate state. Implementation: constraints, triggers, validation. Example: account balance never negative. All business rules enforced. If operation violates constraint, transaction aborts. Ensures valid database state always maintained."},
    {"id": 10, "question": "What is Isolation?", "answer": "Isolation: concurrent transactions don't interfere. Each isolated. Results as if sequential (serializability). Prevents: dirty reads (uncommitted data), non-repeatable reads (value changes), phantom reads (new rows). Levels: read uncommitted (all problems), read committed, repeatable read, serializable (no problems). Trade-off: higher isolation slower. Default varies DBMS."},
    {"id": 11, "question": "What is Durability?", "answer": "Durability: once committed, data persists. Survives failures (crashes, power loss, disk errors). Implementation: write-ahead logging (WAL). Before commit, log written to disk. If failure, recovery replays log. Committed transactions re-executed (redo). Ensures committed data never lost. Critical for reliability. Slight performance overhead justified."},
    {"id": 12, "question": "What are SQL JOINs?", "answer": "JOINs combine rows from multiple tables. Types: INNER (matching both), LEFT (all left + matching right), RIGHT (all right + matching left), FULL OUTER (all both), CROSS (Cartesian product), SELF (table itself). Essential for relational queries. Example: SELECT * FROM Students INNER JOIN Courses ON Students.StudentID = Courses.StudentID. Multiple joins enable complex queries."},
    {"id": 13, "question": "DELETE vs TRUNCATE vs DROP?", "answer": "DELETE: specific rows via WHERE, DML command, slow (row-by-row), fires triggers, rollback possible. TRUNCATE: all rows, DDL command, fast (deallocates), no triggers, limited rollback. DROP: entire table + structure, DDL, fastest, removes definition. Use: DELETE specific rows, TRUNCATE clear table, DROP remove table. Different purposes require different commands."},
    {"id": 14, "question": "What are Indexes?", "answer": "Index: data structure improving retrieval speed. Types: primary, unique, composite, full-text. Advantages: faster SELECT, sorting (ORDER BY), uniqueness enforcement. Disadvantages: slows INSERT/UPDATE/DELETE, extra disk, maintenance overhead, limited benefit small tables. Trade-off: read speed vs write performance. Essential for large tables, frequently queried columns."},
    {"id": 15, "question": "What is Denormalization?", "answer": "Denormalization: intentionally introducing redundancy improving query performance. Opposite normalization. Reasons: improve performance, reduce JOINs, simplify queries. Disadvantages: redundancy, update anomalies, inconsistency risk, complex maintenance. Use judiciously in read-heavy systems. Monitor integrity. Balance performance vs consistency. Selective denormalization practical approach."},
    {"id": 16, "question": "What is Transaction?", "answer": "Transaction: sequence of SQL operations as single unit (ACID). TCL commands: COMMIT (save permanently), ROLLBACK (undo), SAVEPOINT (intermediate checkpoint). Ensures: atomicity, consistency, isolation, durability. Example: BEGIN; UPDATE account SET balance=balance-100; COMMIT; All-or-nothing execution. Prevents partial updates. Essential for data consistency."},
    {"id": 17, "question": "WHERE vs HAVING?", "answer": "WHERE: filters rows before grouping, used without GROUP BY, cannot use aggregates. Example: SELECT * FROM sales WHERE amount > 1000. HAVING: filters groups after grouping, used with GROUP BY, uses aggregates. Example: SELECT dept, SUM(salary) FROM emp GROUP BY dept HAVING SUM(salary) > 100000. Different filtering stages. WHERE applied first (rows), HAVING applied later (groups)."},
    {"id": 18, "question": "What are Subqueries?", "answer": "Subquery (inner query): query within another query. Types: correlated (references outer), non-correlated (independent). Locations: SELECT, FROM (derived table), WHERE. Operators: IN, EXISTS, ALL, ANY. Advantages: modularity, reusability. Example: SELECT name FROM students WHERE studentID IN (SELECT studentID FROM enrollment WHERE courseID=5). Flexible query construction."},
    {"id": 19, "question": "What is Data Redundancy?", "answer": "Data redundancy: duplicate data multiple places. Types: controlled (intentional), uncontrolled (anomalies). Problems: update anomalies (inconsistency), insertion anomalies (cannot insert), deletion anomalies (data loss). Solutions: normalization, referential integrity (FK), proper design. Balance needed: reduce redundancy vs performance. Normalization primary solution."},
    {"id": 20, "question": "What is View?", "answer": "View: virtual table from query result. No physical storage. Advantages: security (hide columns), simplify complex queries, abstraction, maintenance, restrict data. Types: simple (single table), complex (JOINs/multiple). Creation: CREATE VIEW name AS SELECT ... Cannot always UPDATE/DELETE. Enables logical organization."},
    {"id": 21, "question": "What is Trigger?", "answer": "Trigger: stored procedure automatically executing on events. Events: INSERT, UPDATE, DELETE. Timing: BEFORE, AFTER. Advantages: enforce rules, audit trails, prevent invalid, automate. Disadvantages: debug difficult, performance impact, hidden logic, maintenance complex. Example: update last_modified on record change. Hidden execution important consideration."},
    {"id": 22, "question": "What is Concurrency Control?", "answer": "Concurrency control: manages simultaneous transactions maintaining integrity. Problems: dirty reads, non-repeatable reads, phantom reads, lost updates. Levels: read uncommitted, read committed, repeatable read, serializable. Techniques: locking, MVCC, timestamp. Trade-off: concurrency vs consistency. Essential for multi-user systems. Different DBMS default levels."},
    {"id": 23, "question": "What is Locking?", "answer": "Locking: concurrency control preventing simultaneous modifications. Types: shared (read, multiple), exclusive (write, single), intent. Deadlock prevention: timeout, ordering, detection. Problems: deadlock, reduced concurrency, overhead. Lock granularity: row, page, table. Pessimistic approach: assume conflict. Limits performance but ensures correctness."},
    {"id": 24, "question": "What is MVCC?", "answer": "MVCC (Multi-Version Concurrency Control): optimistic concurrency, multiple versions coexist. Benefits: high concurrency, readers/writers don't block, snapshot consistency. Implementation: version tracking, visibility rules, garbage collection. Examples: PostgreSQL, Oracle. Read latest committed. Improves scalability vs locking. More complex but better performance."},
    {"id": 25, "question": "What is Query Optimization?", "answer": "Query optimization: improving execution efficiency. Techniques: index usage, join order, predicate pushdown, redundancy elimination. Optimizer decides plan. Cost-based: estimates costs, chooses minimum. EXPLAIN shows plans. Helps identify inefficiencies. Index design critical. Query rewrites help. Significant performance impact."},
    {"id": 26, "question": "What is Backup and Recovery?", "answer": "Backup/recovery: protecting against data loss. Backup types: full, incremental, differential. Recovery: restore from backup, apply transaction logs, return consistent state. RPO (recovery point): data loss tolerance. RTO (recovery time): downtime tolerance. Critical business continuity. Regular testing important. Off-site backups recommended."},
    {"id": 27, "question": "What is Replication?", "answer": "Replication: copying data across databases/servers. Types: master-slave (one source), master-master (bidirectional), logical, physical. Benefits: availability, load distribution, geographic redundancy, disaster recovery. Challenges: consistency, latency, complexity. Used scalability, reliability. Synchronous/asynchronous trade-offs."},
    {"id": 28, "question": "What is Connection Pooling?", "answer": "Connection pooling: managing database connections efficiently. Process: create pool, reuse connections, avoid overhead. Benefits: better performance, resource efficiency, simplified management, scalability. Configuration: pool size, timeout, validation. Significantly reduces overhead. Essential web applications. Examples: HikariCP, C3P0."},
    {"id": 29, "question": "What is Partitioning?", "answer": "Partitioning: dividing table smaller parts. Types: range (value ranges), list (specific values), hash (hash function), composite. Benefits: better performance, easier maintenance, parallel queries, smaller indexes. Trade-offs: complexity, overhead. Improves scalability large tables. Particularly helpful frequently accessed tables."},
    {"id": 30, "question": "What is Sharding?", "answer": "Sharding: horizontal partitioning across servers. Data distributed shard key. Benefits: scalability, improved performance, geographic distribution, parallelization. Challenges: complex implementation, cross-shard queries difficult, rebalancing complex. Shard selection critical. Used distributed systems. Examples: MongoDB, Cassandra support."},
    {"id": 31, "question": "What is CAP Theorem?", "answer": "CAP theorem: distributed systems guarantee 3 properties. Consistency (all read same), Availability (always responsive), Partition tolerance (survives failures). Can guarantee only 2 of 3. CP: consistent, partition tolerant (availability sacrificed). AP: available, partition tolerant (consistency sacrificed). Explains design decisions distributed systems."},
    {"id": 32, "question": "What is Eventual Consistency?", "answer": "Eventual consistency: replicas eventually consistent. Temporary inconsistency allowed. Benefits: high availability, partition tolerance, performance. Trade-off: consistency delayed. Applications handle. Example: social media updates eventually visible. Contrast strong consistency. Practical web scale. NoSQL systems often implement."},
    {"id": 33, "question": "What is Schema?", "answer": "Schema: database structure definition. Contains: tables, columns, data types, constraints, relationships, indexes. Represents business logic structure. Physical schema: how stored. Logical schema: abstract. External schema: user view. Design critical performance, maintainability. Schema migration: changing structure. Versioning helps changes."},
    {"id": 34, "question": "What is Constraint?", "answer": "Constraint: rule enforcing data validity. Types: NOT NULL (required), UNIQUE (distinct), PRIMARY KEY (unique identifier), FOREIGN KEY (referential), CHECK (condition), DEFAULT (default value). Benefits: data integrity, prevents invalid, enforces relationships. Implementation: database enforced (preferred), application enforced. Enforces business rules."},
    {"id": 35, "question": "What is Cascade Delete?", "answer": "Cascade delete: parent deletion triggers child deletion. Referential integrity enforcement. Implementation: FOREIGN KEY ... ON DELETE CASCADE. Benefits: maintains consistency, prevents orphans, automatic cleanup. Risks: unexpected deletions, data loss. Alternatives: SET NULL, RESTRICT. Careful consideration needed. Document cascade relationships."},
    {"id": 36, "question": "What is Entity-Relationship Model?", "answer": "ER model: conceptual model representing entities, attributes, relationships. Components: entity (object), attribute (property), relationship (association). Cardinality: one-to-one, one-to-many, many-to-many. ER diagram: visual. Used database design planning. Maps relational model. Intermediate requirements-schema. Helps stakeholder communication."},
    {"id": 37, "question": "What is Aggregation?", "answer": "Aggregation: combining rows single result. Functions: COUNT (rows), SUM (total), AVG (average), MIN/MAX. Usage: SELECT COUNT(*) FROM table GROUP BY department. Used GROUP BY. Produces summary data. Important reporting. Performance considerations: large groups. Indexing helps."},
    {"id": 38, "question": "What is Transaction Log?", "answer": "Transaction log: record all modifications. Contains: transaction ID, operation type, before/after values, timestamp. Benefits: recovery, audit trail, replication, forensics. Ensures durability (ACID). Flushed disk before commit. Recovery: redo committed, undo uncommitted. Circular logs systems. Important reliability."},
    {"id": 39, "question": "What is Checkpoint?", "answer": "Checkpoint: point where database state saved disk. Process: flush dirty pages, write checkpoint, update info. Benefits: faster recovery (start checkpoint), log truncation, reduced recovery time. Trade-offs: I/O overhead, pause. Periodic/triggered checkpoints. Critical recovery efficiency. Modern DBMS implement regularly."},
    {"id": 40, "question": "What is WAL (Write-Ahead Logging)?", "answer": "Write-Ahead Logging: logging before actual write. Process: log written, flushed disk, data modified, committed logged. Ensures: no data loss, durability, consistent recovery. ACID guarantee. Essential reliability. Slight overhead justified. Implemented universally modern DBMS. Enables crash recovery safety."},
    {"id": 41, "question": "What is Redo and Undo?", "answer": "Redo: replaying committed transactions after failure. Ensures durability. Undo: reverting uncommitted. Ensures atomicity. Combined: redo log (redo entries), undo log (old values). Recovery: undo uncommitted, redo committed. Ensures consistency crash. Important reliability. Proper logging essential."},
    {"id": 42, "question": "What is Stored Procedure?", "answer": "Stored procedure: reusable SQL program stored database. Benefits: performance (preprocessed), security (access control), reusability, reduced bandwidth, encapsulation. Parameters: IN, OUT, INOUT. Returns sets/status. Control flow support. Disadvantages: database dependent, complex testing, maintenance. Used complex operations."},
    {"id": 43, "question": "What is Function?", "answer": "Function: similar stored procedure returns value. Scalar functions single value. Table functions result. Benefits: reusability, performance, security. Used expressions: SELECT name, dbo.GetAge(birthdate) FROM emp. Deterministic reliable. Non-deterministic complex. Different stored procedures (no OUT params)."},
    {"id": 44, "question": "What is Cursor?", "answer": "Cursor: mechanism processing query results row-by-row. Types: forward only, scrollable. Operations: OPEN, FETCH, UPDATE/DELETE, CLOSE. Disadvantages: overhead, resource consumption, complexity. Modern systems prefer set-based. Appropriate specific scenarios: batch, complex logic. Largely replaced better approaches. Performance consideration."},
    {"id": 45, "question": "What is Deadlock in DBMS?", "answer": "Deadlock: two+ transactions waiting each other's locks. Circular wait stalemate. Example: T1 locks A wants B; T2 locks B wants A. Both wait indefinitely. Prevention: lock ordering, timeouts, detection. Detection: wait-for graph detects cycles. Victim selection rollback. Rare well-designed systems. Automatically handled DBMS."},
    {"id": 46, "question": "What is Isolation Level?", "answer": "Isolation level: concurrency problem degree allowed. Levels: read uncommitted (all), read committed (no dirty), repeatable read (no dirty/non-repeatable), serializable (no problems). Higher stronger consistency, lower concurrency. Default varies DBMS. Trade-off consistency performance. Select appropriate requirement."},
    {"id": 47, "question": "What is Dirty Read?", "answer": "Dirty read: reading uncommitted data another transaction. Problem: rolled back = invalid. Prevention: read committed+ isolation. Avoided locking, MVCC. Most applications require least read committed. Concurrency problem. Causes incorrect results. Security concern data integrity."},
    {"id": 48, "question": "What is Non-Repeatable Read?", "answer": "Non-repeatable read: two reads same data return different. Cause: another transaction modified between. Prevention: repeatable read+ isolation. Locks/MVCC. Affects consistency. Problematic calculations. Example: read value 100, modify, read again 50. Different reads same transaction."},
    {"id": 49, "question": "What is Phantom Read?", "answer": "Phantom read: new rows appear repeated query. Cause: another transaction inserted between. Prevention: serializable isolation. Range locks required. Serious concurrency problem. Affects counts, aggregates. Example: SELECT COUNT(*) different values repeated. Most serious concurrency issue."},
    {"id": 50, "question": "What is Normalization vs Denormalization Trade-off?", "answer": "Normalization: reduces redundancy, improves consistency, saves space, increases JOINs (slower reads). Denormalization: increases redundancy, improves read speed, complex maintenance, requires sync. Decision: OLTP normalize (consistency), OLAP denormalize (performance), data warehouse denormalize. Must workload. Monitoring adjustments."}
  ]
}